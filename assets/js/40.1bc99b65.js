(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{438:function(t,n,e){t.exports=e.p+"assets/img/lock_compatiable.fe1bd5c8.png"},439:function(t,n,e){t.exports=e.p+"assets/img/Universe_of_Serializable.8d0e3635.jpg"},466:function(t,n,e){"use strict";e.r(n);var s=e(2),a=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"事务的并发控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事务的并发控制"}},[t._v("#")]),t._v(" 事务的并发控制")]),t._v(" "),n("p",[t._v("事务：一串SQL操作的序列")]),t._v(" "),n("p",[t._v("事务的四大特性：ACID")]),t._v(" "),n("p",[t._v("A: Atomicity\n含义：要么不做，要么都做。\n方式：1.Undo log    2.Shadow Paging，在副本上更新，一般用于更新不频繁的场景")]),t._v(" "),n("p",[t._v("C: Consistency\n含义：1.数据库一致性：数据满足完整性约束且逻辑正确  2.事务一致性：事务提交前后，数据库一致性不变。\n方式：通过原子性+隔离性+持久性一起来保证")]),t._v(" "),n("p",[t._v("I：Isolation\n含义：并发的事物之间不会相互影响，等效于事务序列化执行。\n方式：并发控制")]),t._v(" "),n("p",[t._v("D: Durablity\n含义：事务被提交后，该数据库的改变是永久的\n方式：redo log")]),t._v(" "),n("h2",{attrs:{id:"并发控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并发控制"}},[t._v("#")]),t._v(" 并发控制")]),t._v(" "),n("h3",{attrs:{id:"相关概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#相关概念"}},[t._v("#")]),t._v(" 相关概念")]),t._v(" "),n("p",[n("strong",[t._v("锁分类")]),t._v("\n共享锁 shared lock 行/表锁\n互斥锁 exclusive lock 行/表锁\n意向共享锁 intention shared lock 表锁 场景：一个事务上表锁之前要检查该表是否有存在的行锁，通过检查意向锁，快速得到结果\n意向互斥锁 intention exclusive lock 表锁\n共享意向互斥锁 shared intention exclusive lock 共享表锁 + 意向互斥锁 场景：一个事务读取表中所有数据，只更新一小部分数据\n"),n("img",{attrs:{src:e(438),alt:""}})]),t._v(" "),n("p",[n("strong",[t._v("Execution Schedule 执行调度")]),t._v("：DBMS执行的操作的顺序\n串行调度（Serial Schedule）：事务之间没有重叠操作的调度（下一个事务等上一个执行完）\n等效调度（Equivalent Schedule）：两种可以产生相同结果的调度\n可串行调度（Serializable Schedule）：可以被等效为串行调度的调度，如果原调度中，两个事务有重叠的操作，但是可以和某一种无重叠的调度得到一样的结果。\n"),n("strong",[t._v("冲突操作")]),t._v("\n读-写：事务1读A，然后事务2写A。 问题："),n("strong",[t._v("不可重复读")]),t._v("，同一个事务内，两次读到的东西不一致\n写-读：事务1写A，然后事务2读A。 问题："),n("strong",[t._v("脏读")]),t._v("，读到其他事务未提交的修改\n写-写：事务1写A，然后事务2写A。 问题："),n("strong",[t._v("脏写")]),t._v("，一个事务覆盖了另一个未提交事务的数据")]),t._v(" "),n("h3",{attrs:{id:"控制协议"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#控制协议"}},[t._v("#")]),t._v(" 控制协议")]),t._v(" "),n("p",[t._v("Two Phase Locking （2PL）两阶段锁：\n第一个阶段： Growing 此阶段只能请求锁\n第二个阶段： Shrinking 此阶段只能释放锁，从释放第一个锁开始")]),t._v(" "),n("p",[t._v("2PL产生的调度，都是可串行化的。（跟事务隔离级别的串行执行不一样-commit之后下一个执行）。")]),t._v(" "),n("p",[t._v("普通的2PL满足重复串行化。事务的序列化指图中的Serial.\n"),n("img",{attrs:{src:e(439),alt:""}})]),t._v(" "),n("p",[t._v("存在的问题：1.级联回滚（严格二阶段锁协议解决） 2.脏读（强二阶段锁协议解决） 3.死锁（死锁检测）")]),t._v(" "),n("h3",{attrs:{id:"_15445-project4-基于2pl实现隔离级别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_15445-project4-基于2pl实现隔离级别"}},[t._v("#")]),t._v(" 15445 Project4-基于2PL实现隔离级别")]),t._v(" "),n("p",[t._v("读未提交：解决脏写。how? 默认加了行写锁。事务结束时释放\n读已提交：解决脏读。 how? 行写锁的基础上，加了行读锁（读完即快速释放）\n可重复读：解决不可重复读。 how? 在以上基础上，延时行读锁的释放，在事务结束时才释放\n可串行化： 解决幻读。幻读的原因：同一事务的两次相同的范围查询，中间有别的事物插入或删除了一些行，导致结果不同。 how? 在以上基础上，对范围里的行加读锁。所以，可以在index上加锁。")]),t._v(" "),n("p",[t._v("实际上上述实现，其中的读完快速释放的锁，没有遵守2PL的定义，但满足效果，且提供更高的并发。")])])}),[],!1,null,null,null);n.default=a.exports}}]);